# stage 0

## tests
- Функциональные тесты
-- Статические страницы +
-- Каталог + фильтр + корзина + заказ
-- Поиск
-- Обратная связь
-- Вход/регистрация + провайдеры
- Визуальные тесты

## seo && performance 
- insert Yandex && Google scripts

## optimization


## chords
- site attacks
- Firefox: arrows on number field
- deploy timeline?

# stage 1

- активно мониторить 404 ошибки в логе и др. инструментах, возможно потребуется добавить редиректы
- redesign: добавить воздуха
- gmail warning: Будьте осторожны! Это письмо не аутентифицировано и отправитель не подтвержден. Лучше не нажимать на ссылки в этом письме, не скачивать прикрепленные файлы и не сообщать отправителю свои личные данные. (Возможно, перейти с admin на info (не забыть сменить MAIL_USER && MAIL_PASS))   
- подумать над алгоритмом поиска: ич-1 0-1 дает нерелевантный результат в быстром поиске
- не смог изменить цвет текста у активного пункта в верхнем меню. active-class не хочет принимать соответствующий класс (text-orange-300). Проверить поведение в следующих релизах.
- создать единый кеш для товаров, получаемых от getProducts.js (= /getData/products) (на данный момент используется в компонентах корзины и просмотренных товаров). Также изменить логику корзины - хранить в useCart только id и количество, а сами товары брать из кеша/сервера.
- ProductsSlider: добавить кнопки прокрутки
- Подумать про сохранение быстрых заказов (сейчас не сохраняются в базе)
- сохранять дату обновления страницы товара/категории и вставлять эту информацию в sitemap (lastmod). P.S. в базе у товаров уже есть поля date_modified и date_price_changed, правда пока не понятно, как будет обновляться date_modified.
- (Yandex Maps JS API): Invalid API key
- Изображения в каталоге: привести все к 1:1 ratio и попробовать ai upscaling (хотя бы до 800px)
- https://github.com/danielroe/beasties - inline critical css. Do not work with Nuxt dynamic pages now (as I understand, only with static html files). Maybe will be in future.
- install Nuxt Web Vitals and connect it to Google Analytics.

# Copilots:
- Gringo675 - 25
- Gringo675-duo - 17 (перепрыгнуло на 19, когда пытался переключится на акк 19 августа) (что-то странное с аккаунтом, всегда квота выбрана и до 19...)
- Gringo675-jet2 - 01 (тоже перепрыгнуло на следующий месяц)
- Gringo675-jet3 - 11
- Gringo675-jet4 - 20
Пароли у всех одинаковые.

# AI's:
## Design:

https://www.recraft.ai/ figma https://mycolor.space/ https://gradients.app/en/color-wheel# https://colorscheme.ru/#3M61Uw0w0w0w0 https://bgrounds.ru/generator-gradient

## Texts, SEO:

https://www.grammarly.com/ https://rytr.me/ Chat GPT https://notebooklm.google.com/ https://aistudio.google.com/

# ТЕЗИСЫ

Все товары принадлежат категориям (не подкатегориям). Подкатегории характеризуются параметрами, по которым проверяется, входит ли товар в данную подкатегорию. Таким образом, один товар может входить в несколько подкатегорий. То есть все подкатегории – это виртуальные категории. При запросе подкатегории ей отдаются все товары из главной категории, и фильтр с активированными нужными для данной подкатегории параметрами. У товаров нет порядка, то есть он формируется автоматически на основе их параметров. Можно сказать, что он задается фильтром. Сначала товары сортируются по характеристикам самой первой группы фильтра, затем по характеристикам следующей группы и т.д. 10.12.24 Решил на данном этапе ограничиться только существующими категориями (в том числи, что это лучше для приемственности) с минимальным добавлением подкатегорий 3 уровня. В связи с этим каталог категорий тоже сделать похожим на старый сайт. В поиске показывать только подкатегории 2 уровня (+ главные на странице поиска). Также убрал со страницы поиска фильтрацию по категориям (вещь довольно тяжеловесная, нет единственного интуитивно понятного алгоритма фильтрации, и в целом не понятно, нужен ли данный функционал пользователю). Уже после запуска сайта нужно будет переделать структуру категорий на изначально планируемую: множество подкатегорий 2 и 3 уровня, множество путей к единице товара. И тогда можно переделать меню категорий на "современное" ("полноэкранное" с тремя колонками главная категория -> подкатегория -> подподкатегория). Тогда же возможно изменить отражение категорий в поиске. Возможно добавить семантику в поиск. Возможно изменить алгоритм выбора категорий, создав для каждой категории семантическое ядро из наименований входящих в нее товаров. И придумать, как показывать только наиболее релевантные категории, хотя бы в окне быстрого поиска.

## Content management system

Brands - нельзя изменять, таблица полностью перезаписывается. 
Properties - нельзя изменять, таблица полностью перезаписывается. 
Products - нельзя изменять, таблица полностью перезаписывается. 
Documentation - нельзя изменять, таблицы полностью перезаписываются. 
Categories - строки записываются/обновляются через INSERT INTO... ON DUPLICATE KEY UPDATE. Это позволяет не обнулять пропсы в существующих категориях и не затирать добавленные вручную категории 
Единственное, что пока можно делать - присвоить подкатегориям пропсы (не затрутся после обновления) и создать под-под-категории. 
В процессе: добавить в prices&quantity.xlsx сохранение измененной информации в новую базу. 
Важно помнить, что при импорте товаров их ID до и после импорта могут не совпадать (если в старую базу были добавлены товары). Соответственно нужно обновлять связи, ссылающиеся на товары (например, если будет включено кеширование страниц, чистить кеш для обновления "Похожих товаров"). Для переноса категорий добавлены npm-пакеты JSDOM (парсинг описания и характеристик) и prettier (форматирование short_description, description, characteristics). После окончательного переезда базы их нужно будет удалить.
На данный момент (stage0) система следующая: полностью переношу старую базу, и в процессе работы через prices&quantity.xlsx обновлять цены/количество. Если нужно внести изменения в товары/категории/пропсы/документацию - опять полностью переписывать соответствующую таблицу(-цы) из старой базы в новую. Затем на stage1 (после полного перехода на новый сайт) начинать внедрять новую cms систему, только для новой базы.
Решил не переносить функционал ручной цены поставщика, т.к. не пользуюсь.
Внедрил на новом сайте функционал спец.цена, но в текущей реализации нет инструмента для его использования (сделать в новой cms).
Не забыть! Сделал поле vendor_stock строкой в новой базе, чтобы можно было вставлять несколько значений (для ВИНС, ЧИЗ). Внедрить в новой csm.

## Project structure and deploy

Собранный билд посредством скрипта в deploy.js заливается в папку build на сервере. Папка public_html является сим-линком на папку public внутри билда (чтобы отдавать статику через nginx) (не забыть сделать для chelinstrument.ru при переезде). Также в процессе деплоя в папку public прилинковывается папка static со статическими ассетами. Уже сделал, чтобы все бралось с боевого сайта (STATIC_ABSOLUTE_PATH=https://chelinstrument.ru/static/), но важно, чтобы статика лежала и в test.cheinstrument.ru, т.к. на сервере используются относительные пути). (P.S. Переместил static в корень аккаунта, чтобы был единый source of truth для всех сайтов) В целом за обработку статики отвечает серверный мидлвер proxy-static.js (работает только на локалхосте, т.к. на продакшене все линки на статику перехватываются njinx благодаря описанной выше системе симлинков).
Добавил в npm scripts установку константы NUXT_BUILD_MODE. От нее зависит, как генерится robots.txt и в какую папку на сервере заливается билд. Внимание, нужно быть осторожным при деплое, сгенерированный билд должен соответствовать папке (сайту)!!! Заливка продакшн билда на тестовый сайт или тестового билда на продакшн недопустима! 
UPD 07.11.25 Столкнулся сразу с двумя похожими проблемами:
1) При формировании билда нужно предварительно удалять папку .nuxt, иначе на странице /catalog сыпятся ошибки - сервер при ssr вставляет неверные ссылки на ресурсы (похоже с предыдущей генерации).
2) На продакшн сервере, связано с .htaccess - невозможно напрямую прописать доступ к index.mjs, только через прокси entry.js. Иначе на всех каталожных страницах (/catalog, категории, товары), как и в предыдущем пункте, сервер вставляет пути к несуществующим файлам (похоже тоже из предыдущего билда).
Причины такого поведения мне тяжело понять... Надеюсь первый пункт поправят в релизах (это явный баг, легко тестится на локальной машине, но только не понятно, почему только на странице /catalog, что в ней особенного). Со вторым можно смириться.
Убрал '/catalog': { prerender: true }. Ошибка исчезла. Хз, возможно конфликтует с правилом '/catalog/**', хотя не должен. Пусть пока так.

## Images

Попытка внедрения NuxtImage оказалась неудачной. Не удалось нормально соединить с действующей системой отдачи статики через Nginx (да по сути мне и не нужен этот модуль на данном этапе). Поэтому все руками: создаем нужные изображения через скрипты в /api/imgOptimisation/, закидываем на сервер, прописываем <picture>.
С изображениями для каталога тоже не все гладко, мечты разбились о суровую реальность: используемые сейчас изображения довольно низкого качества (не все даже дотягивают до 400 px) и полный зоопарк с отношениями сторон. Поэтому более менее нормально удалось настроить только для thumbnails (прописать 2 варианта для разных dpr). Для middle and full все, что удалось - прописать 3 разных формата. Для middle используются в разрешении только ~~400~~ 300 px, для full - в максимально доступном. ToDo: привести все изображения к 1:1 ratio и попробовать ai upscaling (хотя бы до 800px).
Если изменю структуру/качество изображений, не забыть отразить это в useProductsSchema (сейчас для микроразметки берутся изображения из w_max).
upd 16.10.25. Все же решил "вернуться" к формату 2:3 для изображений на странице товара. Началось с оценки производительности в devtools lighthouse, оказалось, что у макета большое смещение, и чтобы это вылечить, нужно задать жестко размеры для контейнера изображения (атрибутов width, height на img недостаточно). Задавать 1:1 было не вариант. Рисерч показал, что Озон и Вайлберрис используют аспект 3:4. Это подтолкнуло откатиться к старым 300х450 px, в будущем постараться привести все изображения к одному формату.

## Data Fetching

Использование "голого" $fetch приводит к двойному запросу к api - с сервера и клиента. Важно учитывать, что при использовании useAsyncData данные в объекте data передаются по ссылке. Т.е. при изменении data и повторном их запросе (например, повторном заходе на страницу) получим уже измененные данные. В том числе, если все или часть данных обернуть в ref (reactive), связь все равно останется. Для получения данных используется компонент HelperDataFetch. Т.к. в опциях стоит deep: false, на выходе получаем shallowRef объект (реактивность реагирует только на полное изменение объекта data, но не его параметров). 
Legacy: При использовании dataFetch c auth = true (=> server = false) && lazy = false необходимо отключить ssr на данной странице (в nuxt.config). Иначе при первоначальной загрузке приложения инициирование useAsyncData будет осуществляться не по ходу выполнения кода в <script setup>, а в хуке onBeforeMounted (=> await перед myFetch не будет останавливать выполнение кода). Как понимаю, чтобы не было hydration error, т.е. результат на сервере и клиенте был одинаковым. Таким образом, если на странице надо обрабатывать данные, полученные через myFetch с server = false, эта страница должна быть server = false, что логично. 
Убрал auth из dataFetch. Для получения данных, требующих авторизации, использовать myFetch, который работает только на клиенте (т.к. запрос с авторизацией можно сделать только с клиента). А dataFetch в первую очередь предназначен для другого: получения данных на сервере при первоначальной загрузке и сохранения их в стейте для использования при гидрации. 
Изменил myFetch. Т.к. изменил систему авторизации с двух токенов на один (куки), система проверки авторизации в myFetch стала неактуальной. Пока по прежнему работает только на клиенте, хотя это можно изменить, если возникнет потребность к примеру получать пользователя при начальной загрузке на сервере. `about dedupe` Нужно понимать, что он относится к запросам, выполняющимся одновременно. Т.е. если есть запрос, ожидающий результат, а ниже по коду еще один такой же запрос, то для второго параметр dedupe будет бесполезен, т.к. в момент его запуска первый уже разрешится. Таким образом, для гарантированного исключения повторных запросов нужно использовать опции dedupe: 'defer' и getCachedData: key => useNuxtData(key).data?.value

## User Auth

~~Аутентификация осуществляется через 2 токена: refreshToken, который хранится в cookie, и sessionToken, который хранится в переменной user (и посылается при требующих аутентификации запросах в хедере).~~ ~~Для упрощения запросов с авторизацией создал composable myFetch, который автоматически добавляет хедер с sessionToken при требующих его запросах и обрабатывает ошибки от сервера.~~ По хорошему все refreshTokens нужно хранить в базе, что позволит увеличить меры безопасности: проверять FingerPrint браузера, проверять максимальное количество токенов на пользователя, удалять все токены при подозрительной активности и т.п. (подробнее https://gist.github.com/zmts/802dc9c3510d79fd40f9dc38a12bccfc). Но пока это решил не реализовывать. Пока только проверяется signature токена и его время жизни, хранящееся в payload. Так как я использую сильно упрощенную систему JWT-токенов (не проверяю refreshToken должным образом, отсутствует сервер авторизации, куки с refreshToken отправляется при каждом запросе, и приложение является монолитом), вполне было бы достаточно использования куки. Это упростит логику приложения, сделает возможным использование myFetch на сервере. refreshToken будет обновлять сам себя, т.е. будет включать в себя sessionToken. Но использовать JWT - это как-то "по-взрослому". И можем в будущем его использование будет оправданно, например, если перестанет быть монолитом и будет использоваться как часть приложения для мобильных девайсов, где нет куки. Переделал систему авторизации на один токен.

## Закрытие сайта для свободного доступа

Осуществляется через глобальную серверную переменную process.env.IS_SITE_CLOSED. Код ответа сервера при закрытом сайте - 423. Проверка при запросах на сервере. Осуществляется в server/middleware/ifSiteClosed.js. Будет пропускать только администраторов, а также запросы на вход (server/api/auth/login.js). При этом в дальнейшем при логировании если юзер окажется не админом, будет возвращена ошибка 423. На сайте не должно быть статичных страниц (т.е. при обращении к любой странице должен быть запрос на сервер). Так гарантируется проверка на доступ к странице.

## Responsive

~~Добавил экраны в tailwind.config.js. Теперь можно пользоваться следующими префиксами (примеры):~~ ~~@md: - только для md экранов (768 - 1023 px)~~ ~~-md: - для всех экранов меньше или входящих в md (до 1023 px)~~ ~~md: - для всех экранов больше или входящих в md (c 768 px). Нативный mobile-first~~ ~~\*После добавления своих экранов перестал работать нативный префикс max-.. Но он полностью заменяется моим префиксом -..~~ ~~Перешел от системы экранов к системе брекпойнтов.~~ 

Перешел на стандартный синтаксис tailwind v4: 
~ max-xs(480)xs ~ max-sm(640)sm ~ max-md(768)md ~ max-lg(1024)lg ~ max-xl(1280)xl ~ max-2xl(1536)2xl ~ 
Примеры: 
md: - для экранов больше или равных 768 px (native mobile first) 
max-md: - для экранов меньше 768 px (от 767 px) 
md:max-lg: - для экранов от 768 до 1023 px (max-lg:md тоже будет работать) 

Tailwind @container (можно использовать с классами, где есть --container-*, например w-3xl): 
@3xs 16rem (256px) 
@2xs 18rem (288px) 
@xs 20rem (320px) 
@sm 24rem (384px) 
@md 28rem (448px) 
@lg 32rem (512px) 
@xl 36rem (576px) 
@2xl 42rem (672px) 
@3xl 48rem (768px) 
@4xl 56rem (896px) 
@5xl 64rem (1024px) 
@6xl 72rem (1152px) 
@7xl 80rem (1280px) 
Кстати, tailwind отдельно в проект устанавливать не нужно, т.к. он входит в NuxtUI.

## Обмен информацией между открытыми вкладками.

Для синхронизации во всех открытых вкладках пользовательских данных следим за localStorage. В ключ user-event записываем следующие значения: 
0 - при выходе пользователя 
1 - при входе 
2 - при обновлении данных о пользователе
Для обеспечения консистентности нужно после каждого "сигнала" удалять ключ user-event. Иначе логика может нарушиться, например, при ручном удаление cookies пользователь будет разлогинен, а user-event останется со значением 1 (залогинен), и не будет реагировать на "сигнал".


## BreadCrumbs

На страницах категорий и товаров используется компонент BreadCrumbsWrapper, который по присланному ИД формирует крошки из категорий. На других страницах сейчас нет breadCrumbs. Нужны ли?

## Lazy Loading and Links Prefetch

Nuxt по-умолчанию старается загрузить компоненты для страниц, ссылки на которые есть на текущей. Можно управлять стратегиями подгрузки через prefetch-on="..." или no-prefetch. Но gemini говорит, что предзагрузка абсолютно не вредит метрикам производительности, т.к. у этих элементов меньший приоритет загрузки и браузер подгружает их только когда idle (вполне возможно, это неправда).
При предзагрузке компоненты с Lazy- не будут загружены.
Теперь про использование Lazy- на активной странице. Если Lazy- компонент используются с v-if, он будет загружен только при срабатывании условия. Но Lazy- можно использовать и без условия, для определения момента гидрации компонента. Для этого необходимо вставлять директивы: hydrate-on-visible, hydrate-on-idle etc. <Lazy... hydrate-never /> = компоненту с суффиксом .server (использовать для статичного контента) (p.s. почти равно. Под капотом .server будет использовать острова, которая пока еще экспериментальная функция, плюс дополнительный overhead при генерации <NuxtIsland>, так что пока остановился на первом варианте).
upd 24.10.25 Поставил для страницы /catalog генерацию только на сервере (index.server.vue) и получил ошибку на продакшене: при переходе на данную страницу с другой все норм, а вот при прямом заходе 404 и слетает верстка. Видимо острова еще рано использовать, или дело в моем довольно специфичном развертывании (Passenger). P.S. возможно что-то глюкануло при сборке проекта, а может дело в PassengerStartupFile index.mjs || PassengerStartupFile entry.js. Пока лень экспериментировать.
upd 07.11.25 Наверно дело не в островах, смотри комментарий в Project structure and deploy

## SEO

Мета поля для категорий и товаров отсутствуют в базе. Генерация title & description осуществляется "на лету" из данных.

## Cashing

Кэширование и переключение ssr/spa для путей настроено в routeRules nuxt.config.ts. Для статичных страниц установлен пререндер.
Изначально планировал использовать следующую настройку для кэша: { swr: true, maxAge: 2 * 60 * 60, staleMaxAge: 12 * 60 * 60, // 12 hours } (т.е. если кэшу меньше 2 часов - отдать кэш, ничего не делать; если от 2 до 12 - отдать старый кэш, сгенерировать новый; больше 12 (или нет) - сгенерировать новый, отдать, положить в кэш). Но оказалось, что в Nitro на текущей стадии абсолютно сломан staleMaxAge (а может никогда и не работал). И вариантов с кэшем 2: старый добрый maxAge (при этом не забыть поставить swr: false, т.к. по-умолчанию от true), либо использовать swr без staleMaxAge, и тогда может найтись счастливец, которому попадется древняя редко посещаемая страница с устаревшими данными.
В Nuxt официально поддерживается следующая запись:  swr?: number | boolean, т.е. swr: number = swr + maxAge (и никакого staleMaxAge, что намекает на проблемы с параметром).
Пока остановлюсь на swr: 2 * 60 * 60, будем наблюдать за обновлениями.
Если при проектировании админки учесть удаление кэша для обновляемых страниц, тогда в принципе и сам swr будет не нужен, и maxAge можно поставить бесконечный. (P.S. Добавил функционал удаления всего кэша. Как удалить кэш для конкретной страницы (запроса) не разобрался, довольно сложная система формирования ключа из адреса, нужно вникать.)

## Z-index system

В tailwind используются классы от z-0 до z-50. В общих случаях (хедер, модули поиска, юзера, корзины, каталога и тп) использовать z-10. Для элементов, которые всегда должны быть выше предыдущих (меню категорий), использовать z-20. Если этого не достаточно, использовать "арбитральные" значения от z-[21] до z-[29]. Для врапперов модальных полноэкранных окон использовать z-30. Для элементов внутри модальных окон (кнопка закрытия) использовать z-40. Для крайних случаев (лоадер) - z-50. Переписал дефолтное значение для UModal на z-30 (в app.config.ts).

## Forms

Событие валидации на текстовых полях в компоненте UForm срабатывает: при первоначальном вводе - при потере фокуса, при повторных заходах - при вводе каждого символа. Поэтому лучше сделать так, чтобы поля валидировались каждое отдельно (исключить общую валидацию), а функция валидации только собирала ошибки, не выполняя саму валидацию как таковую.

## Консоль на сервере

Использовать функцию cv.
Варианты синтаксиса:
 * cv({var1, var2, var3})
 * for ref and reactive cv({var1}, {var2}, {var3})
 * cv('just text')
 * cv('some text', var1)
Результаты смотреть либо на странице /admin/console (если залогинин как админ), либо в текстовом файле cv_log.txt.
Локально лежит в корне проекта (D:\pr_gt\projects\site\cv_log.txt)
Удаленно на Бегете в /chelinstrument.ru/public_html/test/cv_log.txt . Для слежения удобно использовать putty: tail -f chelinstrument.ru/public_html/test/cv_log.txt

