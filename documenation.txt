    ToDo
labels
cashing
authorization
Error Handling
server checkAndDecodeToken
refreshTokenCheck expires + redirect to login if exp.
modal login?
проверить admin cats

    ТЕЗИСЫ
Все товары принадлежат категориям (не подкатегориям).
Подкатегории характеризуются параметрами, по которым проверяется, входит ли товар в данную подкатегорию. Таким образом, один товар может входить в несколько подкатегорий. То есть все подкатегории – это виртуальные категории.
При запросе подкатегории ей отдаются все товары из главной категории, и фильтр с активированными нужными для данной подкатегории параметрами.
У товаров нет порядка, то есть он формируется автоматически на основе их параметров. Можно сказать, что он задается фильтром. Сначала товары сортируются по характеристикам самой первой группы фильтра, затем по характеристикам следующей группы и т.д.

Data Fetching
Использование "голого" $fetch приводит к двойному запросу к api - с сервера и клиента.
useFetch как-то неккоректно прописывает ключ, поэтому не обновляет данные при изменении alias в пределах одной страницы (думает, что ключ тот же).
Lazy непонятно зачем вообще нужна. Все что делает - это игнорирует await перед вызовом.

Error Handling
Ощущение, что как-то все еще сыро.
Фронту вообще пофиг какие ошибки произошли на сервере при использовании useAsyncFetch. Он все равно продолжает после разрешения промиса (как сможет) выполнять код. То есть нужно на фронте следить за результатом, возвращаемым API, и уже здесь кидать ошибки. Но здесь тоже проблема, так и не понял как получить код ошибки на сервере. У переменной error из useAsyncData только значение true/false (хотя если реактивно следить за ним, на мгновение мигает полная инфа с кодом, описанием и т.п.). И получается что при любой ошибке при получении данных (к примеру обрыв соединения) на фронте вручную ставим 404, что вовсе не верно.
Самый вменяемый результат дало испльзование throw createError({ statusCode: ..., statusMessage: '...', fatal: true}.
showError работает только на клиенте, и самое смешное, после выбрасывания ошибки продолжает выполняться основной код приложения.
/pages/404.vue отлавливает только несуществующие страницы в /pages, но не может отследить динамически создаваемые 404 (через createError).
Остается только использовать error.vue и внутри него разделять ошибки на 500 и 404.
И пока не пойму как получить ошибку с сервера на фронте. Т.е. любая ошибка на сервере сейчас генерирует 404 на фронте.
Как работает NuxtErrorBoundary вообще не могу понять.
Похоже layouts в error.vue не работают. Только руками вставлять нужные компоненты: TheHeader etc. Интересно, что будет, если ошибка произойдет в TheHeader...
Не работает перемотка наверх в error.vue.

User Auth
Аутентификация осуществляется через sessionID, который хранится в cookie и расшифровывается в объект вида user = {isAuth, isAdmin} в middleware на сервере при каждом запросе к api.
Товары в корзине храним в local storage.
При этом компонент Корзина будет ClientOnly и будет косвенно отвечать за начальную аутентификацию пользователя в приложении.
Доступ к ограниченной информации: сервер идентифицирует пользователя, если у того нет права доступа, кидает ошибку авторизации. Фронт должен перехватить такую ошибку и отправить на страницу авторизации.(Проблема в том, что я пока не умею перехватывать код ошибки с сервера).

