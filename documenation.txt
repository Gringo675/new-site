ToDo:
ErrorLogger (+ ошибки при отсутствии интернета)
-image viewer

search: 
    категории: возможно убрать indeterminate и изменение родителей (будет понятно после окончательного формирования категорий, будут ли подкатегории на 100% покрывать родителей) (наверно лучше убрать совсем фильтр с подкатегорий, оставив только главные, и добавить линки)
админка:
    товары - инфо
    товары - цены
    документация (+товары)
алиасы через middleware?
ean === id?

RoadMap:
админка товары
Cashing
ErrorLogger (+ ошибки при отсутствии интернета)
google & yandex services?

    ТЕЗИСЫ
Все товары принадлежат категориям (не подкатегориям).
Подкатегории характеризуются параметрами, по которым проверяется, входит ли товар в данную подкатегорию. Таким образом, один товар может входить в несколько подкатегорий. То есть все подкатегории – это виртуальные категории.
При запросе подкатегории ей отдаются все товары из главной категории, и фильтр с активированными нужными для данной подкатегории параметрами.
У товаров нет порядка, то есть он формируется автоматически на основе их параметров. Можно сказать, что он задается фильтром. Сначала товары сортируются по характеристикам самой первой группы фильтра, затем по характеристикам следующей группы и т.д.

Data Fetching
Использование "голого" $fetch приводит к двойному запросу к api - с сервера и клиента.
useFetch как-то неккоректно прописывает ключ, поэтому не обновляет данные при изменении alias в пределах одной страницы (думает, что ключ тот же)(вроде в свежих релизах исправили).
При использовании dataFetch c auth = true (=> server = false) && lazy = false необходимо отключить ssr на данной странице (в nuxt.config). Иначе при первоначальной загрузке приложения инициирование useAsyncData будет осуществляться не по ходу выполнения кода в <script setup>, а в хуке onBeforeMounted (=> await перед myFetch не  будет останавливать выполнение кода). Как понимаю, чтобы не было hydration error, т.е. результат на сервере и клиенте был одинаковым. Таким образом, если на странице надо обрабатывать данные, полученные через myFetch с server = false, эта страница должна быть server = false, что логично.
Убрал auth из dataFetch. Для получения данных, требующих авторизации, использовать myFetch, который работает только на клиенте (т.к. запрос с авторизацией можно сделать только с клиента). А dataFetch в первую очередь предназдначен для другого: получения данных на сервере при первоначальной загрузке и сохранения их в стейте для использования при гидрации.
Изменил myFetch. Т.к. изменил систему авторизации с двух токенов на один (куки), система проверки авторизации в myFetch стала неактуальной. Пока по прежнему работает только на клиенте, хотя это можно изменить, если возникнет потребность к примеру получать пользователя при начальной загрузке на сервере.

Error Handling
Похоже layouts в error.vue не работают. Только руками вставлять нужные компоненты: TheHeader etc. 
Если ошибка произойдет в TheError при загрузке, он просто не загрузится.
Не работает перемотка наверх в error.vue.


User Auth
Аутентификация осуществляется через 2 токена: refreshToken, который хранится в cookie, и sessionToken, который хранится в переменной user (и посылается при требующих аутентификации запросах в хедере).
Для упрощения запросов с авторизацией создал composable myFetch, который автоматически добавляет хедер с sessionToken при требующих его запросах и обрабатывает ошибки от сервера.
По хорошему все refreshTokens нужно хранить в базе, что позволит увеличить меры безопасности: проверять FingerPrint браузера, проверять максимальное количество токенов на пользователя, удалять все токены при подозрительной активности и т.п. (подробнее https://gist.github.com/zmts/802dc9c3510d79fd40f9dc38a12bccfc). Но пока это решил не реализовывать. Пока только проверяется signature токена и его время жизни, хранящееся в payload.
Так как я использую сильно упрощенную систему JWT-токенов (не проверяю refreshToken должным образом, отсутствует сервер авторизации, куки с refreshToken отправляется при каждом запросе, и приложение является монолитом), вполне было бы достаточно использования куки. Это упростит логику приложения, сделает возможным использование myFetch на сервере. refreshToken будет обновлять сам себя, т.е. будет включать в себя sessionToken. Но использовать JWT - это как-то "по-взрослому". И можем в будущем его использование будет оправданно, например, если перестанет быть монолитом и будет использоваться как часть приложения для мобильных девайсов, где нет куки.
Переделал систему авторизации на один токен.

Закрытие сайта для свободного доступа
Осуществляется через глобальную серверную переменную process.env.IS_SITE_CLOSED. Код ответа сервера при закрытом сайте - 423. Проверка при запросах на сервере.
Осуществляется в server/middleware/ifSiteClosed.js. Будет пропускать только администраторов, а также запросы на вход (server/api/auth/login.js). При этом в дальнейшем при логировании если юзер окажется не админом, будет возвращена ошибка 423.
На сайте не должно быть статичных страниц (т.е. при обращении к любой странице должен быть запрос на сервер). Так гарантируется проверка на доступ к странице.

Responsive
Добавил экраны в tailwind.config.js. Теперь можно пользоваться следующими префиксами (примеры):
@md: - только для md экранов (768 - 1023 px)
-md: - для всех экранов меньше или входящих в md (до 1023 px)
md: - для всех экранов больше или входящих в md (c 768 px). Нативный mobile-first
*После добавления своих экранов перестал работать нативный префикс max-.. Но он полностью заменяется моим префиксом -..

Обмен информацией между открытыми вкладками.
Для синхронизации во всех открытых вкладках пользовательских данных следим за localStorage.
В ключ user-event записываем следующие значения:
0 - при выходе пользователя
1- при входе
timeStamp - при обновлении данных о пользователе



