    ToDo
labels
cashing
modal login?
проверить admin cats

    ТЕЗИСЫ
Все товары принадлежат категориям (не подкатегориям).
Подкатегории характеризуются параметрами, по которым проверяется, входит ли товар в данную подкатегорию. Таким образом, один товар может входить в несколько подкатегорий. То есть все подкатегории – это виртуальные категории.
При запросе подкатегории ей отдаются все товары из главной категории, и фильтр с активированными нужными для данной подкатегории параметрами.
У товаров нет порядка, то есть он формируется автоматически на основе их параметров. Можно сказать, что он задается фильтром. Сначала товары сортируются по характеристикам самой первой группы фильтра, затем по характеристикам следующей группы и т.д.

Data Fetching
Использование "голого" $fetch приводит к двойному запросу к api - с сервера и клиента.
useFetch как-то неккоректно прописывает ключ, поэтому не обновляет данные при изменении alias в пределах одной страницы (думает, что ключ тот же)(вроде в свежих релизах исправили).
При использовании dataFetch c auth = true (=> server = false) && lazy = false необходимо отключить ssr на данной странице (в nuxt.config). Иначе при первоначальной загрузке приложения инициирование useAsyncData будет осуществляться не по ходу выполнения кода в <script setup>, а в хуке onBeforeMounted (=> await перед myFetch не  будет останавливать выполнение кода). Как понимаю, чтобы не было hydration error, т.е. результат на сервере и клиенте был одинаковым. Таким образом, если на странице надо обрабатывать данные, полученные через myFetch с server = false, эта страница должна быть server = false, что логично.
Убрал auth из dataFetch. Для получения данных, требующих авторизации, использовать myFetch, который работает только на клиента (т.к. запрос с авторизацией можно сделать только с клиента). А dataFetch в первую очередь предназдначен для другого: получения данных на сервере при первоначальной загрузке и сохранения их в стейте для использования при гидрации.

Error Handling
Как работает NuxtErrorBoundary вообще не могу понять.
Похоже layouts в error.vue не работают. Только руками вставлять нужные компоненты: TheHeader etc. Интересно, что будет, если ошибка произойдет в TheHeader...
Не работает перемотка наверх в error.vue.


User Auth
Аутентификация осуществляется через 2 токена: refreshToken, который хранится в cookie, и sessionToken, который хранится в переменной user (и посылается при требующих аутентификации запросах в хедере).
Для упрощения запросов с авторизацией создал composable myFetch, который автоматически добавляет хедер с sessionToken при требуещих его запросах и обрабатывает ошибки от сервера.
По хорошему все refreshTokens нужно хранить в базе, что позволит увеличить меры безопасности: проверять FingerPrint браузера, проверять максимальное количество токенов на пользователя, удалять все токены при подозрительной активности и т.п. (подробнее https://gist.github.com/zmts/802dc9c3510d79fd40f9dc38a12bccfc). Но пока это решил не реализовывать. Пока только проверяется signature токена и его время жизни, хранящееся в payload.
Товары в корзине храним в local storage ???
При этом компонент Корзина будет ClientOnly и будет косвенно отвечать за начальную аутентификацию пользователя в приложении.


